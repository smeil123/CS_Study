### 문제 풀기



  
**테이블에서 데이터를 찾는 방법은 아래 두가지**

- 테이블 전체를 스캔한다.

- 인덱스를 이용한다.

  
**인덱스 튜닝의 두가지 핵심요소**

- 인덱스 스캔 효율화 튜닝

- `랜덤 액세스 최소화 튜닝` → 테이블 액세스 횟수를 줄이기

  
  
## 인덱스 수직적 탐색

인덱스 스캔의 시작지점을 찾는 과정

&ensp; &ensp; 루트 블록에서 시작해서 리프 블록까지 수직적 탐색

조건을 만족하는 첫번재 레코드를 찾는 과정

  
수직적 탐색 과정에서 찾고자 하는 값보다 크거나 같은 값을 만나면, 바로 직전 레코드가 가리키는 하위 블록으로 이동한다.

  
만약에 정확히 일치하는 레코드가 있어도, 바로 직전 레코드가 가리키는 하위 블록으로 이동해야 빠트리지 않고 찾는다.

- 하위 블록 왼쪽 : 같거나 작은 값

- 하위 블록 오른쪽 : 같거나 큰 값

## 인덱스 수평적 탐색

본격적으로 데이터를 찾는 과정 → ROWID를 얻는 과정

인덱스 리프 블록끼리는 서로 앞뒤 블록에 대한 주소값을 갖는다.

&ensp; &ensp; 즉, 양방향 연결 리스트 구조

  
## 결합 인덱스 구조와 탐색

인덱스 선두 컬럼을 모두 “=” 조건으로 검색할 때는 어느 컬럼을 앞에 두던 `블록I/O 개수가 같으므로 성능도 똑같다.`

⇒ B*Tree 의 깊이가 동일하므로!

>B는 Balanced 의 약자로, 루트로 부터 모든 리프 블록까지의 높이는 항상 같다.

  
## ?

- 인덱스를 재구성하면 인덱스 스캔 비효율을 줄이는 데는 도움이 되지만, 테이블 엑세스를 줄이는 데는 전혀 도움이 되지 않음

  
- 인덱스 컬럼을 뒤쪽에 추가하면

&ensp; &ensp; - 인덱스 사이즈 증가 ⇒ 리프 블록 수 증가 ⇒ 스캔 효율이 약간 나빠짐

&ensp; &ensp; - 인덱스 높이 증가

&ensp; &ensp; - 클러스터링 팩터가 나빠짐

&ensp; &ensp; &ensp; &ensp; - 값이 같으면 ROWID순으로 정렬하기 때문에 선두컬럼 NDV가 적다면 CF는 비교적 좋은 상태일텐데

&ensp; &ensp; &ensp; &ensp; - 이 상태에서 인덱스를 추가하면 새로운 정렬 기준을 갖게 되므로 CF가 나빠짐

# 클러스터링 팩터

클러스터링 팩터가 좋아지려면

&ensp; &ensp; 인덱스 컬럼 순으로 정렬되되도록 테이블을 재생성

&ensp; &ensp; (인덱스 재생성해도 안좋아짐)

데이터양이 많아지면 인덱스 CF가 나빠지고 버퍼캐시 히트율이 점점 낮아져 ⇒ 인덱스 손익분기점이 내려간다

  
  