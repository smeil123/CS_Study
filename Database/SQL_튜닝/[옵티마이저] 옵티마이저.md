  
## 옵티마이저

  
## 옵티마이저 행동에 영향을 미치는 요소

- 옵티마이징 팩터 : 인덱스, IOT, 클러스터링, 파티셔닝 등 오브젝트 구성

- DBMS 제약 설정 : PK, FK, Check, Not Null

- 통계정보

- 옵티마이저 힌트

- 옵티마이저 관련 파라미터

## 비용기반(Cost-Based)

사용자 쿼리를 위해 후보군이 될만한 실행계획을 도출

데이터 딕셔너리에 미리 수집해 둔 통계정보 이용하여 각 실행계획 예상비용 산정

그 중 가장 낮은 비용의 실행계획 하나를 선택

>비용 : 쿼리를 수행하는 동안 예상되는 I/O 횟수 또는 예상 소요시간

- 사용하는 통계정보

&ensp; &ensp; - 테이블 통계

&ensp; &ensp; &ensp; &ensp; - 데이터양

&ensp; &ensp; &ensp; &ensp; - 블록 수

&ensp; &ensp; &ensp; &ensp; - 평균 행 길이

&ensp; &ensp; - 컬럼 통계

&ensp; &ensp; &ensp; &ensp; - 중복을 제거한 컬럼 값의 수

&ensp; &ensp; &ensp; &ensp; - 최소값

&ensp; &ensp; &ensp; &ensp; - 최대값

&ensp; &ensp; &ensp; &ensp; - Null 값 개수

&ensp; &ensp; &ensp; &ensp; - 히스토그램

&ensp; &ensp; &ensp; &ensp; - XX 최소 컬럼 길이, 최대 컬럼 길이 이딴건 수집안함

&ensp; &ensp; - 컬럼 값 분포

&ensp; &ensp; - 인덱스 통계 

&ensp; &ensp; &ensp; &ensp; - 인덱스 높이, 리프 블록 개수

&ensp; &ensp; - 클러스터링 팩터

&ensp; &ensp; - 시스템 통계

&ensp; &ensp; &ensp; &ensp; - CPU속도

&ensp; &ensp; &ensp; &ensp; - Single Block I/O 속도

&ensp; &ensp; &ensp; &ensp; - Multi Block I/O 속도

&ensp; &ensp; &ensp; &ensp; - 평균적인 Multiblock I/O 개수

&ensp; &ensp; &ensp; &ensp; - XX Single Block I/O 개수는 당연히 1이니까 이것도 수집하지 않음

&ensp; &ensp; >버퍼캐시 크기는 실행계획 수립말고 런타임 시 고려사항
라이브러리 캐시 또한 실행계획에 영향을 주지 않음(다만 실행계획이 자주 밀려날 뿐)

내부적으로 규칙도 갖고 활용함

EX) 어떤 인덱스를 사용하던 비용이 동일하면 알파벳 순으로 선택

옵티마이저 모드가 first_rows인 경우, order by 컬럼 인덱스 사용

### 한계

기본적으로 캐싱 효과를 고려하지 않음 ⇒ 모든 블록을 디스크에서 읽는다고 가정

&ensp; &ensp; 최근 `CPU 비용 모델` 에서 예상 I/O 발생량을 디스크에서 단일 블록을 읽을 때의 시간으로 환산한 Cost를 사용하므로 이 역시 캐싱 효과를 고려하지 않음

&ensp; &ensp; 참고로, optimizer_index_caching 파라미터를 통해 일부 캐싱 효과를 고려하도록 설정할 수는 있음

  
### 참고

테이블 통계, 인덱스 통계, 컬럼 통계는 하드 파싱 과정에 수집하는 것이 아니라 DBA가 설정한 주기에 따라 미리 수집해 둔다.

다이나믹 샘플링이 필요한 상황이면 하드 파싱 과정에서 통계정보를 수집하긴 하지만, 이를 딕셔너리에 저장하지는 않음

## 규칙기반(Rule-Based)

**통계정보를 전혀 활용하지 않고 단순 규칙에만 의존 ⇒ 대량 데이터 처리에 부적절**

  
인덱스 구조, 연산자, 조건절 형태가 순위를 결정하는 주요소

  
# 서브 엔진

- Query Transformer : 사용자로부터 전달받은 SQL을 그대로 최적화 X , 우선 최적화에 유리한 형태로 변환 시도

- Estimator : 선택도, 카디널리티, 비용을 계산하고, 실행계획 전체에 대한 총 비용 계산

- Plan Generator : 후보군 실행계획 생성

  
# 옵티마이저가 힌트를 무시하는 경우

1. 문법적이 틀림

1. 잘못된 참조 사용

1. 논리적으로 불가능한 액세스 경로

1. 의미적으로 맞지 않음

1. `옵티마이저에 의해 내부적으로 쿼리가 변환` 

1. 버그

  
# 스스로 학습하는 옵티마이저

- Adaptive Cursor Sharing : 처음 실행 시 특정 실행계획으로 실행하다 바인드 변수가 변경되었을 때 많은 I/O가 발생하면 실행계획을 추가로 생성하고, 이후에 바인드 변수 값 분포에 따라 다른 실행계획을 선택적으로 사용하는 기능

- Cardinality Feedback(Statistics Feedback) : 최초 실행계획을 수립할 때 추정했던 카디널리티와 실제 실행 과정에 읽은 로우 수 간에 차이가 크면, 조정된 카디널리티 값을 저장해두었다 활용함

- Adaptive Plans : 런타임에 실행계획을 변경가는 기능들을 포함

&ensp; &ensp; - EX) 통계정보 상 A와 B가 둘 다 작은 집합이라고 판단해서 옵티마이저가 NL 조인을 선택했는데, 실제 많은 로우가 반환되면 해시 방식으로 조인 변경

  
↔ Bind Variable Peeking(Parameter Sniffing) : 첫 번째 수행된 바인드 변수를 살짝 보고 실행계획은 결정하는 기능으로, 바인드 변수를 사용하면 히스토그램을 활용하지 못하는 제약을 극복하기 위한 기능

  
  
## I/O 비용모델 vs CPU 비용모델

### I/O 비용 모델

- 비용 : 예상되는 디스크 I/O Call 횟수

&ensp; &ensp; - 블록 개수가 아님, Single Block I/O인 경우 I/O Call이 읽은 블록 수와 동일하겠지만 멀티일 때는 아님 더 많이 읽음

### CPU 비용 모델

- 비용 : 예상 I/O 시간과 예상 CPU사용시간을 구하고 → Single Block I/O 시간으로 나눈 값

&ensp; &ensp; - 즉, 비용을 Single Block I/O에 소요되는 시간과의 상대적인 시간 비용으로 계산한것

&ensp; &ensp; - 우리 시스템에서 100번 Single Block I/O하는 정도의 시간이 소요될 것으로 예상

  
## 히스토그램 유형

- 도수분포 : 값별로 빈도수 저장

- 높이균형 : 각 버킷의 높이가 동일하도록 데이터 분포 관리

- 상위도수분포 : 많은 레코드를 가진 상위 n개 값의 빈도수 저장

- 하이브리드 : 도수본포와 높이균형 히스토그램의 특성 결합

  
  
### 비용 산정


 ``` 
비용 = 브랜치 레벨
	    + (리프 블록 수 * 유효 인덱스 선택도)
      + (클러스터링 팩터 * 유효 테이블 선택도)
 ``` 


  