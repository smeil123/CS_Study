## 이벤트 루프란?
필요할때(언제든지) 시스템 커널에 작업을 떠넘겨서 노드가 논 블로킹 I/O작업을 수행하도록 해줌
작업 중 하나가 완료되면 커널에 노드에게 알려주어 적절한 콜백을 poll큐에 추가할 수 있게함(poll큐에 넣고 순서가 되면 실행되도록)
> javascript가 싱글스레이드임에도 불구하고 여러 작업을 동시에 진행하게 해주는 녀석

nodejs는 초기화된 이벤트 루프를 통해 순차적으로 작업을 수행한다.

사진은 첨부하자
대략
timers - pending callbacks - idle, prepare - poll - check - close callback

“각 박스는 이벤트 루프의 단계를 의미”

* 각 단계는 실행할 콜백의 큐를 가짐
* 이벤트 루프가 해당 단계에 진입하면 한정된 작업을 수행함(큐의 작업을 모두 소진하거나, 최대 개수를 실행) -> 다음 단계로 이동
* 이벤트 루프에서 시행하는 작업이 다른 작업을 스케줄링하거나, poll단계에서 처리된 새로운 이벤트가 커널에 의해 큐에 추가될 수 있으므로 폴링 이벤트를 처리하면서 poll이벤트를 큐에 추가할 수 있음

### 단계 개요
* timers : setTimeout()과 setInterval()로 스케줄링한 콜백을 실행
* pending callbacks : 다음 루프 반복으로 연기된 I/O 콜백 실행
* idle, prepare : 내부용으로만 사용
* poll : 새로운 I/O이벤트를 가져옴. I/O와 연관된 콜백(클로즈 콜백, 타이머 스케줄 콜백, setImmediate()를 제외한 거의 모든 콜백)을 실행함. 적절한 시기에 노드는 여기서 블록함
* check : setImmediate() 콜백 호출
* close, callbacks : 일부 close콜백들, 예를 들어 socket.on('close',..)

이벤트 루프가 실행하는 사이 노드는 다른 비동기 I/O나 타이머를 기다리고 있는지 확인하고 기다리는 것이 없다면 깔끔하게 종료한다
-> 종료?

## 각 단계별 소개
#### timers
타이머는 사람이 실행하기를 원하는 정확한 시간이 아니라, 제공된 콜백이 일정 시간후에 실행되어야하는 **기준시간**을 지정한다. -> 운영체제 스케줄링 혹은 다른 콜백 영향으로 기준시간 이후에 실행될 수 있음


<!--stackedit_data:
eyJoaXN0b3J5IjpbMTg2Njk1NzQ4Myw1NTAyOTIxMjEsLTExNz
c2MDg1NThdfQ==
-->