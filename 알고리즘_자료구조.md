## 배열과 연결리스트 차이
**배열**
* 데이터를 논리적 순서에 따라 순차적으로 데이터를 입력, 물리적 주소또한 순차적이다
* 인덱스를 가지고 있어서 원하는 데이터를 한번에 접근가능하기 때문에 접근속도가 매우 빠르다
* 반면에, 삭제/삽입에 취약하다. 배열 특성상 데이터 삽입/삭제가 이루어지면 삽입/삭제가 이루어진 다음부터 모든 데이터의 위치를 변경해야하기 때문이다.

**연결리스트**
* 연결리스트는 데이터를 논리적 순서에 따라 데이터를 입력한다. 하지만 물리적 주소는 순차적이지 않다.
* 인덱스를 가지고 있는 배열과는 달리 연결리스트는 인덱스 대신 현재 위치의 이전 및 다음 위치를 기억하고 있다
* 한번에 데이터 접근이 가능하지 않고 연결되어 있는 링크를 따라가야만 접근이 가능하고, 배열에 비해 속도가 떨어진다.
* 데이터 삽입/삭제는 논리적 주소만 바꿔주면 되기 때문에 용이하다.

### 구조체
* typedef 키워드 : C언어에서 자료형을 새롭게 이름을 붙일 때 쓰는 키워드이다. typedef를 이용하면 main함수에서 구조체를 선언할 때 매번 struct를 써줄 필요가 없다. 구조체 별칭이 필요하다.

## 스택이란 무엇인가(자료구조와 컴퓨터 구조 측면에서)
* 한 쪽 끝에서만 자료를 넣고 뺄 수 있는 LIFO형식의 자료구조
**배열 스택**
```
<push>
IF TOP > MAX THEN
	OVERFLOW
ELSE
	TOP = TOP+1
	STACK[TOP] = DATA
<POP>
IF TOP == -1 THEN
	UNDERFLOW
ELSE
	DATA = STACK[T0P]
	TOP = TOP - 1
```
**연결리스트 스택**
// ... n번째 들어온 노드 -> n-1번째 들어온 노드 -> .... -> 1번째 들어온 노드 -> null
```
typedef struct NODE{
	int data;
	struct NODE *next;
}NODE;
typedef struct STACK{
	*NODE top;
}
<초기화>
STACK s;
s -> top = NULL;

<push>
NODE *now = (NODE *)malloc(sizeof(NODE));
now -> data = data;
now -> next = s -> top;
s -> top = now;

<pop>
Node *now;
if(IsEmpty(stack)){ return 0;}
now = stack -> top;
stack->top = now->next;
free(now);
```

## 큐란?
* 한쪽 끝에서 자료를 넣고 반대쪽끝에서 자료를 뺄 수 있는 FIFO 형식의 자료구조
**배열 큐** // 오버플로우를 조심해야한다
```

```
## 우선순위 큐

## 힙이란?


## 정렬
### 퀵정렬

### 힙정렬

### 기수정렬

### 위상정렬

## 탐색
### 이분탐색

### selection

## 그래프
### dfs

### bfs

### 다익스트라

### 벨만포드
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTg0NzI3NDA3Myw5NDM3MjgyMywtMzkyMj
U4NzMsMTIxODcxMTgxNywtMTE3MzcwNTMxOCwyNDMxNDk3MjIs
MjA4MDgxNTYxN119
-->