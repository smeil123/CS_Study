## 배열과 연결리스트 차이
**배열**
* 데이터를 논리적 순서에 따라 순차적으로 데이터를 입력, 물리적 주소또한 순차적이다
* 인덱스를 가지고 있어서 원하는 데이터를 한번에 접근가능하기 때문에 접근속도가 매우 빠르다
* 반면에, 삭제/삽입에 취약하다. 배열 특성상 데이터 삽입/삭제가 이루어지면 삽입/삭제가 이루어진 다음부터 모든 데이터의 위치를 변경해야하기 때문이다.

**연결리스트**
* 연결리스트는 데이터를 논리적 순서에 따라 데이터를 입력한다. 하지만 물리적 주소는 순차적이지 않다.
* 인덱스를 가지고 있는 배열과는 달리 연결리스트는 인덱스 대신 현재 위치의 이전 및 다음 위치를 기억하고 있다
* 한번에 데이터 접근이 가능하지 않고 연결되어 있는 링크를 따라가야만 접근이 가능하고, 배열에 비해 속도가 떨어진다.
* 데이터 삽입/삭제는 논리적 주소만 바꿔주면 되기 때문에 용이하다.

### 구조체
* typedef 키워드 : C언어에서 자료형을 새롭게 이름을 붙일 때 쓰는 키워드이다. typedef를 이용하면 main함수에서 구조체를 선언할 때 매번 struct를 써줄 필요가 없다. 구조체 별칭이 필요하다.

## 스택이란 무엇인가(자료구조와 컴퓨터 구조 측면에서)
* 한 쪽 끝에서만 자료를 넣고 뺄 수 있는 LIFO형식의 자료구조
**배열 스택**
```
<push>
IF TOP > MAX THEN
	OVERFLOW
ELSE
	TOP = TOP+1
	STACK[TOP] = DATA
<POP>
IF TOP == -1 THEN
	UNDERFLOW
ELSE
	DATA = STACK[T0P]
	TOP = TOP - 1
```
**연결리스트 스택**
// ... n번째 들어온 노드 -> n-1번째 들어온 노드 -> .... -> 1번째 들어온 노드 -> null
```
typedef struct NODE{
	int data;
	struct NODE *next;
}NODE;
typedef struct STACK{
	*NODE top;
}
<초기화>
STACK s;
s -> top = NULL;

<push>
NODE *now = (NODE *)malloc(sizeof(NODE));
now -> data = data;
now -> next = s -> top;
s -> top = now;

<pop>
Node *now;
if(IsEmpty(stack)){ return 0;}
now = stack -> top;
stack->top = now->next;
free(now);
```

## 큐란?
* 한쪽 끝에서 자료를 넣고 반대쪽끝에서 자료를 뺄 수 있는 FIFO 형식의 자료구조
**배열 큐** // 오버플로우를 조심해야한다
* 원형 큐로 구현한다. 왜냐하면 배열은 크기가 정해져있기 때문에.
```
<push>
IF ((TAIL+1 % SIZE)) == HEAD) { FAIL; }
ELSE {
	QUEUE[TAIL] = DATA;
	TAIL = (TAIL + 1) % SIZE;
}
<pop>
IF (TAIL == HEAD) { EMPTY; }
ELSE {
	DATA = QUEUE[HEAD];
	HEAD = (HEAD+1)%SIZE;
}
<empty>
IF( TAIL == HEAD ) TRUE;
```
**연결리스트큐**
```
typedef struct Node
{
	int data;
	struct Node *next;
}Node;
typedef stuct Queue
{
	Node *front;
	Node *rear;
	int count;
}Queue;

<init>
queue -> front = queue -> rear = NULL;
queue -> count = 0;

<enqueue>
Node *node = (Node *)malloc(sizeof(Node));
node -> data = data;
node -> next = NULL;
if(IsEmpty(queue)){ queue-> front = node; }
else { queue -> rear -> next = node; }
queue -> rear = node;
queue -> count++;

<dequeue>
if(IsEmpty(queue)) { false; }
Node *now = queue -> front;
int data = now -> data;
queue -> front = now -> next;
queue -> count--;
free(now);

```
## 스택 2개 -> 큐
inBox -> outBox
1. inBox에 데이터를 push -> A,B
2. inBox에 있는 데이터를 pop 하여 outBox에 push -> B,A
3. outBox에 있는 데이터를 pop -> A,B

## 우선순위 큐


## 정렬
| Name | Best | Age | Worst|
|--|--|--|--|
|삽입정렬| n | n^2 | n^2|
|선택정렬|n^2|n^2|n^2|
|버블정렬|n^2|n^2|n^2|
|셸정렬|n|n^1.5|n^2|
|퀵정렬|nlogn|nlogn|n^2|
|힙정렬|nlogn|nlogn|nlogn|
|병합정렬|nlogn|nlogn|nlogn|
|기수정렬|kn|kn|kn|kn|
### 퀵정렬
기준이 되는 원소를 이용해서 정렬
* x <= pivot < x
이렇게 나눈 뒤 분할/정복한다.
**정렬방식**
1. 기준이 되는 원소를 설정. 시작원소를 pivot으로
2. 좌우 인덱스 지정
	* left : pivot보다 큰 값을 찾으러 다니는 index
	* right : pivot보다 작은 값을 찾으러 다니는 index
3. left를 pivot보다 큰 값을 찾을 때 까지 이동한다
4. right를 pivot보다 작은 값을 찾을 때까지 이동한다.
5. left <= right 조건이라면 두 원소를 스왑한다.
6. 3,4번과정을 left <= right 만족할 때까지 반복
7. left와 right가 교차하게 되면 right 위치에 pivot값을 대입
8. right를 기준으로 분열된 배열에 대해서 퀵 정렬을 1부터 반복
```
void QuickSort(int base[], int l, int r){
	int i = left, j = right 
}
```
### 힙정렬
* 항상 완전 이진트리
* 부모의 값 >= 자식들의 값 ( 최대 힙) (<-> 최소 힙)
* 최대값 찾는데 O(1)
* 삽입/삭제 속도 O(logN)
**데이터 삽입**
1. 가장 끝의 자리에 노드 삽입
2. 그 노드와 부모노드를 서로 비교
3. 규칙이 맞으면 그대로 두고, 그렇지 않으면 부모와 교환
4. 규칙에 맞을 때까지 3번의 과정을 반복

**데이터 삭제**
최대값 혹은 최솟값이 저장된 루트 노드만 제거할 수 있다
1. 루트노드를 제거한다
2. 루트 자리에 가장 마지막 노드를 삽입한다.
3. 올라간 노드와 그의 자식 노드를 비교한다.
4. 조건에 만족하면 그대로 두고, 그렇지 않으면 자식과 교환한다
	* 최대 힙
	1. 부모보다 더 큰 자식이 없으면 교환하지 않고 끝낸다.
	2. 부모보다 더 큰자식이 하나 있으면 그 자식하고 교환하면 된다.
	3. 두개 있으면 자식들 중 큰 값과 교환한다.
5. 조건을 만족할 때까지 4번 과정을 반복한다.
   
```
<삽입>
void insert_heap(HeapTyep *h, element item){
	int i;
	i = ++(h->heap_size);
	while((i!=1) && (item.key > h -> heap[i/2].key)){
		h->heap[i] = h->heap[i/2];
		i /= 2;
	}
	h->heap[i] = item;
}
```
### 기수정렬
* 데이터끼리의 직접적인 비교 없이 정렬 수행
* k가 상수일 경우 시간복잡도 O(n)
**정렬 방식**
1. 0~9까지의 큐를 준비
2. 모든 데이터에 대하여 가장 낮은 자리수에 해당하는 큐에 차례대로 데이터를 둔다
3. 0부터 차례대로 버킷에서 데이터를 가져온다
4. 가장 높은 자리수를 기준으로 하여 자리수를 높여가며 2~3번 과정을 반복한다.

### 위상정렬
* 방향 그래프에 존재하는 각 정점들의 선행 순서를 위배하지 않으면서 모든 정점을 나열하는 것
* 하나의 그래프에는 여러 위상 정렬이 가능한다
* 진입 차수가 0인 정점이 없으면 해결할 수 없다.
**정렬 방식**
큐를 이용해서 정렬한다!
1. 진입 차수가 0인 정점(즉, 들어오는 간선의 수가 0)을 선택
	* 진입 차수가 0인 정점이 여러개 존재하면 어느 정점을 선택해도 무방
	* 초기에 간선의 수가 0인 모든 정점을 큐에 삽입
2. 선택된 정점과 여기에 부속된 모든 간선을 제거
	* 선택된 정점을 큐에서 삭제
	* 선택된 정점에 부속된 모든 간선에 대해 간선의 수를 감소
3. 위의 과정을 반복해서 모든 정점이 선택, 삭제되면 알고리즘 종료

## 탐색
### 이분탐색(binary Search)


### selection

## 그래프
### dfs

### bfs

### 다익스트라

### 벨만포드
<!--stackedit_data:
eyJoaXN0b3J5IjpbNzgyNzI4MzQ0LDE0NjU1MjQyMzksLTg3OD
A3ODU0NywtOTk2NDA3MzIyLDYxMzIwNTQ2MSwtMTkzNjAwOTU1
MCwtMTIxNDkyMDgwNSw1MzU0NTAwNzQsMTk5OTkzNTkwMiw4OT
kyODY3NTMsOTQzNzI4MjMsLTM5MjI1ODczLDEyMTg3MTE4MTcs
LTExNzM3MDUzMTgsMjQzMTQ5NzIyLDIwODA4MTU2MTddfQ==
-->