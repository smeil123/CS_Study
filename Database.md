# 데이터베이스론 정리

## 기존의 파일 처리 방식에서의 문제점
### 종속성으로 인한 문제점
* 종속성 : 응용프로그램과 데이터 파일이 상호 의존적인 관계
* 데이터 파일이 보조 기억 장치에 저장되는 방법이나 저장된 데이터의 접근 방법을 변경할 때는 응용프로그램도 같이 변경하여야함

### 중복성으로 인한 문제점
* 일관성 : 중복된 데이터간에 내용일 일치하지 않는 상황이 발생하여 일관성이 없어짐
* 보안성 : 중복되어 있는 모든 데이터에 동등의 보안수준을 유지하기가 어려움
* 경제성 : 저장 공간의 낭비와 동일한 데이터의 반복 작업으로 인한 비용의 증가
* 무결성 : 제어의 분산으로 인해 데이터의 정확성을 유지할 수 없음

## 데이터베이스 언어
### 데이터 정의 언어 (DDL : Data Definition Language)
* Create, Alter, Drop, Rename

### 데이터 조작 언어 (DML : Data Manipulation Language)
* Select, Insert, Update, Delete

### 데이터 제어 언어 ( DCL : Data Control Language)
* Grant, Revoke, Commit

## 데이터 모델의 구성 요소
* 개체 (Entity)
* 속성 (Attribute)
* 관계 (Relationship)

* 튜플 = 행
* 차수 = 속성의 개수
* 기수 = 카디날리티 = 튜플의 개수

## 키의 개념 및 종류
* 후보키 : 튜플을 유일하게 식별하기 위한 속성들의 부분집합, 유일성과 최소성
* 기본키 : 후보키 중에서 선택한 주키, Null값을 가질 수 없음
* 대체키 : 후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키
* 슈퍼키 : 유일성은 지키지만 최소성은 만족시키지 못하는 속성의 집합
* 외래키 : 관계를 맺고 있는 릴레이션을 참조하는 키

## 무결성
* 개체 무결성 : 릴레이션에서 기본키를 구성하는 속성은 Null값이나 중복값을 가질 수 없음
* 참조 무결성 : 외래키값은 널이거나 참조 릴레이션의 기본키값과 동일해야함 

## 데이터베이스 설계 단계
1. 요구사항 수집 및 분석
2. 개념적 설계
3. 논리적 설계
4. 정규화
5. 물리적 설계
6. 데이터베이스 튜닝

## 스키마의 정의
* 데이터베이스의 구조와 제약조건에 관한 전반적인 명세를 기술함
* 데이터베이스를 구성하는 데이터 엔티티, 애트리뷰트(속성), 관계 및 제약조건 등에 관해 전반적으로 정의함

### 스키마 3계층
* 외부 스키마(External Schema) = 사용자 뷰
	* 뷰사용자나 응용프로그래머가 각 개인의 입장에서 필요로하는 데이터베이스의 논리적인 구조
	* 여러 개의 외부스키마가 존재함
* 개념 스키마 = 전체적인 뷰
	* 통합한 조직 전체의 데이터베이스로 하나만 존재함
	* 단순히 스키마라고하면 개념스키마를 의미
* 내부 스키마
	* 데이터베이스의 물리적 구조
	* 데이터의 실제 저장 방법 기술
	* 물리적인 저장장치와 밀접한 계층
	* 시스템 프로그래머나 시스템 설계자가 보는 관점의 스키마


## 관계대수(절차적 언어)
* 원하는 목표 데이터를 얻기 위해 어떻게 해야되는지 일련의 연산을 순서대로 명세해야한다
*  반면, 관계 해석은 무슨 데이터를 원하는지만 선언하면 된다(순서X)

* Select = 시그마(릴레이션 이름)
* Project = 파이(릴레이션 이름) => 속성추출
* Join = (릴레이션) 리본(조건) (릴레이션)
* Division = R나누기S =>R의 속성이 S의 속성값을 모두 가진 튜플에서 S가 가진 속성을 제외한 값 구함 

  
## 함수적 종속성
* 함수적 종속성 X -> Y는 릴레이션 내 임의이의 두 튜플에서 속성 X의 값이 같을 경우, 속성 Y의 값도 항상 같음을 의미한다.
 
## 정규화
* 제1정규화
	* 모든 도메인이 원자값을 가진다.
* 제2정규화
	* 제 1정규화를 만족하고, 완전 함수적 종속성을 가진다.
		* 기본키가 1개인 경우에는 항상 만족한다.
* 제3정규화
	* 제 2정규화를 만족하고, 이행적 함수 종속성이 없어야한다
* BCNF
	* 제3정규화를 만족하며, 결정자이면서 후보키가 아닌 것이 없다.

## 트랜잭션의 정의
* 데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업의 단위
* 하나의 트랜잭션은 commit되거나 rollback됨
* 트랜잭션은 일반적으로 회복의 단위가 된다

### 트랜잭션의 특징 (ACID)
* Atomicity(원자성) : 모두 반경되거나 전혀 반영되지 않아야 한다
* Consistency(일관성) : 트랜잭션이 성공하면 데이터베이스는 일관성을 유지해야한다
* Isolation(독립성) : 트랜잭션이 실행 중에 다른 트랜잭션이 끼어들 수 없다
* Durability(지속성) : 트랜잭션이 성공되면 그 상태가 영구적으로 반영되어야 한다.


### 회복
회복 개념 : 트랜잭션들을 실행하는 도중 장애가 발생하여 데이터베이스가 손상되었을 경우 손상되기 이전의 정상 상태로 복구하는 작업
**회복기법**
1. 연기 갱신 기법
	* 트랜잭션이 성공적으로 종료될 때까지 데이터베이스에 대한 실질적인 갱신을 연기하는 기법
	* 트랜잭션이 실행되는 동안 병경된 내용은 로그에 보관
	* 트랜잭션의 부분 완료 시점에 저장된 로그를 사용하여 변경 내용을 실제 데이터베이스에 반영
	* 부분 완료되기 전에 장애 발생 -> Rollback되어도 디비에 저장된 값이 없기 때문이 무시
	* 저장되기 직전 장애 발생 -> Redo
2. 즉각 갱신 기법
	* 트랜잭션이 데이터를 변경하면 트랜잭션이 부분 완료되기 전이라도 즉시 실제 데이터베이스에 반영
	* 장애가 발생하여 회복 작업을 수행할 경우에 대비하여 변경도니 모든 내용들은 로그에 보관
	* 회복 작업을 수행할 경우에는 Redo와 Undo작업이 모두 수행
3. 그림자 페이지 기법
	* 갱신 이전의 데이터베이스를 일정 크기의 페이지 단위로 구성하여 각 페이지마다 복사본인 그림자 페이지로 별도 보관해 두고, 실제 페이지를 대상으로 트랜잭션에 대한 변경 작업을 수행하는 기법
	* 즉, 복사본에다가 변경작업을 수행하는 것
	* 장애가 발생하여 트랜잭션 작업을 Rollback시킬 때는 그림자 페이지를 변경된 이후의 실제 페이지 부분에 대체하여 회복
	* 회복을 위해 로그를 유지할 필요가 없으며, 회복 작업을 수행할 경우에도 Redo, Undo작업을 수행할 필요가 없다.
4. 검사점 기법(check point)
	* 시스템 장애가 발생하였을 경우, Redo와 Undo를 수행하기 위해 로그 전체를 조사해야 하는 경우를 피하기 위한 기법
	* 트랜잭션 실행 중 주기적으로 변경 내용이나 시스템 상황 등에 관한 정보와 함께 체크포인트를 로그에 보관
	* 장애 발생 시 로그 전체를 조사하지 않고 로그 내에서 가장 최근의 검사점으로부터 회복 작업을 수행하여 회복 시간을 단축
5. 미디어 회복 기법
	* 데이터베이스 내용을 주기적으로 안전한 저장 장치에 덤프해 놓는다
	* 디스크 장애가 발생하면 가장 최근의 덤프 내용을 디스크에 적재하고, 로그를 이용하여 가장 최근 덤프 이후 완료된 트랜잭션들에 대해 Redo 작업을 수행한다. (Undo는 필요없다)

### 병행제어
병행제어 개념 : 다중 프로그램의 이점을 활용하여 동시에 여러 개의 트랜잭션을 병행 수행할 때 실행되는 트랜잭션들이 데이터베이스의 일관성을 파괴하지 않도록 트랜잭션 간의 상호 작용을 제어하는 기술

목적
* 공유를 최대화
* 시스템 활용도를 최대화
* 응답시간 최소화
* 단위 시간당 트랜잭션 처리 건수를 최대화
* 데이터베이스 일관성 유지
**필요성**
병행 제어 없이 트랜잭션들이 데이터베이스에 동시에 접근하도록 허용할 경우 다음과 같은 문제점 발생
1. 갱실 분실 : 2개 이상의 트랜잭션이 같은 데이터를 공유하여 갱신할 때 갱신 결과의 일부가 없어지는 현상
2. 모순성 : 복수의 사용자가 동시에 같은 데이터를 갱신할 때 데이터베이스 내의 데이터들이 상호 일치하지 않아 모순된 결과 발생
3. 연쇄 복귀 : 병생 수행되던 트랜잭션들 중 어느 하나에 문제가 생겨 Rollback되는 경우 다른 트랜잭션들도 함께 Rollback되는 현상

### 병행제어 관리
#### Lock
개념 : 데이터베이스 관리에서 하나의 트랜잭션에 사용되는 데이터를 다른 트랜잭션이 접근하지 못하게 하는 것을 의미
* 데이터 갱신 시 : lock -> execute -> unlock 규칙을 따라야함
* 잠금 단위 : 데이터베이스, 테이블, 레코드, 필드
* 잠금 단위가 크면 -> 관리하기 쉽지만 공유성 수준이 낮아짐
* 잠금 단위가 작으면 -> 관리하기 복잡하지만 공유성 수준이 높아진다
* 교착상태가 발생할 수 있다.
* Shared-lock(읽기), Exclusive-lock(읽기, 쓰기) 
#### 병행제어 기법의 종류
1. 2단계 lock protocol
* 트랜잭션 스케줄의 직렬성을 보장하는 대표적인 잠금 기법
* 잠금과 잠금해제를 2단계로 수행
	* 확장 단계 : 잠금만 수행, 잠금 해제 불가
	* 축소 단계 : 잠금 해제만 수행, 잠금 수행 불가
* 직렬성은 보장하지만 교착상태를 예방할 수는 없다.
2. Time stamp ordering 
* 시스템이 각 트랜잭션을 실행할 때 타임스탬프를 부여한다.(트랜잭션이 시스템에 들어온 시간 값)
* 트랜잭션들을 인터리빙하게 실행한 결과가 시간 스템프 순서대로 트랜잭션들을 실행하는 직렬 스케줄의 실행 결과와 항상 동일하다는 것을 보장하는 기법이다
* 직렬성 순서를 결정하기 위해 트랜잭션 간의 실행 순서를 미리 결정하는 기법들 중 가장 보편적인 방법
* 타임 스탬프 순서 기법은 읽거나 변경할 데이터에 대해 트랜잭션을 실행하기 전에 타임 스탬프를 부여하고 타임 스탬프 순서에 따라 트랜잭션 작업을 수행하도록 한다.
* 교착 상태가 발생하지 않는다\\## 트랜잭션 격리성
Lock을 강하게 오래 유지할수록 격리성이 강화되고, lock을 최소화할 수록 약화된다

#### 낮은 단계의 격리성 수준에서 발생할 수 있는 현상들
1. Dirty Read
다른 트랜잭션에 의해 수정됐지만 아직 커밋되지 않은 데이터를 읽는 것을 말한다. 변경 후 아직 커밋되지 않은 값을 읽었는데 변경을 가한 트랜잭션이 최종적으로 롤백된다면 그 값을 읽은 트랜잭션은 비일관된 상태에 놓이게 된다.
2. Non-Repeatable Read
한 트랜잭션 내에서 같은 쿼리를 두 번 수행했는데, 그 사이에 다른 트랜잭션이 값을 수정 또는 삭제하는 바람에 두 쿼리 결과가 다르게 나타나는 현상을 말한다
3. Phantom Read
한 트랜잭션 내에서 같은 쿼리를 두 번 수행했는데, 첫 번째 쿼리에서 없던 유령 레코드가 두 번째 쿼리에서 나타나는 현상을 말한다.

#### 트랜잭션 격리성 수준
ANSI/IOS SQL표준에서 정의한 4가지 트랜잭션 격리성 수준은 다음과 같다.
1. Read Uncommitted
트랜잭션에서 처리 중인 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용한다.
2. Read Committed
트랜잭션이 커밋되어 확정된 데이터만 다른 트랜잭션이 읽도록 허용함으로써 Dirty Read를 방지해준다.
하지만 Non-Repeatale read 와 Phantom read 현상을 막지는 못한다. 읽는 시점에 따라 결과가 다를 수 있다. 한 트랜잭션 내에서 쿼리를 두 번 수행했는데 두 쿼리 사이에 다른 트랜잭션이 값을 변경/삭제하거나 새로운 레코드를 삽입하는 경우에 이런 일이 발생한다.
3. Repeatable Read
트랜잭션 내에서 쿼리를 두 번 이상 수행할 때, 첫 번째 쿼리에 있던 레코드가 사라지거나 값이 바뀌는 현상을 방지해준다. 이 트랜잭션 격리성 수준이 Phantom Read현상을 막지는 못한다. 첫 번째 쿼리에서 없던 새로운 레코드가 나타날 수 있다. 한 트랜잭션 내에서 쿼리를 두 번 수행했는데 두 쿼리 사이에 다른 트랜잭션이 새로운 레크드를 삽입하는 경우에 이런 일이 발생한다.
4. Serializable Read
트랜잭션 내에서 쿼리를 두 번 이상 수행할 때, 첫 번째 쿼리에 있던 레코드가 사라지거나 값이 바뀌지 않음은 물론 새로운 레코드가 나타나지 않는다.

### NoSQL이란
* 관계형 데이터베이스보다 덜 제한적인 일관성 모델을 이용하는 데이터의 저장 및 검색을 위한 매커니즘을 제공한다.
* 단순 검색 및 추가 작업을 위한 매우 최적화된 키-값 저장 공간을 사용한다.
* 빅데이터 시대에 따라 많은 양의 데이터를 효율적으로 처리하기 위해 등장하였다. (비정형 데이터를 보다 쉽게 담아서 처리할 수 있다)
* 분산형 구조를 통해 여러 대의 서버에 분산해 저장하고, 분산시에는 데이터를 상호 복제에 특정 서버에 장애가 발생했을 때에도 데이터 유실이나 서비스 중지가 없는 형태의 구조를 갖고 있다.

### Nosql vs rdbms
* 스키마가 없다. 즉 데이터 관계에 정해진 규격이 없다
* 관계 정의가 없으니 join이 불가능하다 (하지만 reference와 같은 기능으로 비슷하게 구현은 가능)
* 트랜잭션을 지원하지 않는다
* 분산처리의 기능을 쉽게 제공한다
* 대부분의 nosql db는 분산처리기능을 목적으로 나왔기 때문에 분산처리 기능을 자체 프레임워크에 포함하고 있다.

## 인덱스 튜닝
* 인덱스는 큰 테이블에서 소량의 데이터 검색시 성능을 좋게해주는 것이다
* 튜닝의 핵심은
	* 인덱스 스캔 효율화 튜닝
	* 랜덤 엑세스 최소화 튜닝
		* 테이블 엑세스 횟수를 줄이는 것(인덱스로 데이터를 필터링할 수 없는 경우 테이블에 엑세스해서 데이터를 비교한다)
	> 인덱스를 최대한 활용해서 인덱스 스캔을 하는 것이 목적

* 수직적 탐색과 수평적 탐색을 통해 인덱스를 활용하면서 검색을 하는 것임을 이해해야한다.
	* 수직적 탐색 : 검색의 시작점을 찾는 것 (루트노드 ~ 리프노드)
	* 수평적 탐색 : 검색의 범위를 찾는 것(리프노드 ~ 리프노드)

### 인덱스 사용이 불가한 경우
1. 인덱스 컬럼을 가공한 경우
	* 검색의 시작점을 찾을 수 없어 풀 스캔을 해야됨
2. like, OR 조건을 사용한 경우
	* like의 경우 %대한% 을 검색한 경우는 당연 풀스캔
	* OR조건은 각각의 조건의 시작점을 찾아야되기에 한 시작점을 짚을 수 없음
	   * 대신, union all 로 쿼리문을 작성하면 Index Range Scan 가능
3. IN 조건절을 사용한 겨웅
	* OR조건과 동일한 이유로 불가능하지만
	* SQL 옵티마이저가 IN-List Iterator방식으로 UNION ALOL방식으로 풀어주면 Index Range Scan이 가능하다.
4. 복합인덱스의 경우, 인덱스 선두 컬럼을 조건절에 사용하지 않은 경우
5.
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE4NDU3MzkxMTgsLTEyNzA0MDcxODQsLT
E5MDYwMzM5NDAsMTQ2ODQ4NjY0NF19
-->