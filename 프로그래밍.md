# 프로그래밍 기본
### C언어와 C++언어의 차이점
* 데니스리치가 개발한 언어로 인간의 명령어를 컴퓨터가 이해할 수 있도록 기계어로 변환해주는 역할을 하는 프로그램
* C언어
	* 절차지향 패턴.
	* 같은 이름을 가진 함수가 존재할 수 없다.
	* 변수, 함수를 초기에 작성해야한다.
* C++
	* C언어를 확장시킨 언어
	* 객체지향 패턴
	* 같은 이름을 가진 함수 존재 가능(오버로딩, 오버라이딩)
	* 변수,함수를 중간에 어디서든 선언이 가능하다.

### 클래스와 구조체의 차이점
* 구조체는 하나의 구조로 묶일 수 있는 데이터. 즉 변수들의 집합
* 클래스는 변수 뿐만 아니라 함수(메서드)까지도 포함시킬 수 있다
* 하지만, C에서도 함수포인터를 이용해 구조체를 클래스화 시킬 수 있다.

### 전역변수
* 어디서나 접근가능
* 프로그램의 시작과 동시에 메모리 공간에 할당되어 종료시까지 존재한다.
* 별도의 값으로 초기화하지 않으면 0으로 초기화된다.
* 동일한 이름의 지역변수는 해당 영역의 동일한 전역변수를 가진다?

### 지역변수에 static선언을 추가해서 만드는 static변수
* 지역변수가 전역변수의 성격을 띄게된다.
* 함수가 호출되면 선언되고 선언된 함수 내에서만 접근이 가능 -> 지역변수
* 딱 1회 초기화되고 프로그램 종료시까지 메모리공간에 존재 -> 전역변수
*  애초에 전역변수로 선언하면 같은 역할을 할 수 있지만 static으로 선언함으로써 접근 범위를 제한할 수 있다. 

### Register변수
* register int num=3;
* CPU내에 존재하는 ‘레지스터’ 메모리 공간에 저장될 확룔이 높아진다

### 스크립트 언어 vs 컴파일 언어
* 스크립트 언어(JavaScript, Python, Ruby..) : 컴파일러가 존재하지 않는다. 실행될 때 바로 해석하므로 코드 변경시 실행 할 때마다 결과가 바뀌게 된다.
* 컴파일러 언어(C,C++,C#,Java) : 컴파일러가 존재한다. 한번 컴파일 된 후에는 코드 수정 후 재 컴파일을 하기전까지 같은 결과를 나타낸다.
* 
### Javascript "단일 스레드"
Javascript의 큰 특징 중 하나는 단일 스레도 기반의 언어라는 점이다. 즉, 동시에 하나의 작업만을 처리할 수 있다라는 말이다.(단일 호출 스택 엔진 사용)
* 어떻게 동시에 여러가지 요청을 처리할 수 있을까? -> **이벤트 루프**
* 즉, 자바스크립트는 이벤트 루프를 이용해서 비동기 방식으로 동시성을 지원한다. (동기방식 : Java)
#### ECMAScript에는 이벤트 루프가 없다
(ECMAScript는 자바스크립트를 표준화하는 언어이다)
즉, ECMAScript에는 동시성과 비동기와 관련된 언급이 없다.
JavaScript의 동시성은 자바스크립트 엔진을 구동하는 환경, 즉 브라우저나 Node.js가 담당한다.
![eventloop](https://github.com/smeil123/CS_Study/blob/master/image/eventloop.png)
(출처 : [https://meetup.toast.com/posts/89](https://meetup.toast.com/posts/89) )
사진에서 알 수 있듯이 비동기 호출을 위해 사용되는 setTimeout이나 XMLHttpRequeset와 같은 함수들은 자바스크립트 엔진이 아닌 Web API영역에 따로 정의되어 있다. 또한 이벤트루프와 태스크 큐와 같은 장치도 자바스크립트 엔진 외부에 구현되어 있는 것을 볼 수 있다.
![nodejs](https://github.com/smeil123/CS_Study/blob/master/image/nodejs.jpg)
(출처 : [https://meetup.toast.com/posts/89](https://meetup.toast.com/posts/89) )
Node



### 자바스트립트 특징 중 비동기
* 비동기처리란? : 특정 코드의 연산이 끝날 때까지 코드의 실행을 멈추지 않고 다음 코드를 먼지 실행하는 것
* 서버에 get요청을 하거나 settimeout 함수를 실행하는 경우에 발생한다.
* 해결방법 -> callback함수 이용
**callback 함수**

```
function getdata(callbackFunc){
	$.get(url,function(rep{
		callbackFunc(rep);
	});
}
getdata(function (tableData){
	console.log(tableData);
});
```

**콜백 지옥**
```
$.get(url,function(rep){
	A(rep, function(a){
		B(a, function(b){
			C(c, function(c){
				console.log(c);
			}
		}
	}
});
```
비동기 처리해야하는 경우 콜백안에 콜백을 계속 무는 형식으로 코딩하게 되는데, 이는 코드구조와 가독성이 떨어지고 로직을 변경하기도 어렵다. 이를 콜백 지옥이라고 한다.

**콜백 지옥 해결방법**
일반적으로 promise나 async를 사용한다
```
function A(a){
	B(a, adone);
}
function B(b){
	C(b, adone);
}
function C(c){
	console.log(c);
}
$.get(url,function(rep){
	A(rep, done);
});

```



### OPP vs 절차지향
* 절차지향, 구조적 프로그래밍(C) : 초창기에 많이 사용한 방법으로 순차적 프로그래밍이라고도 한다. 해야할 작업을 순서대로 코딩을 한다. 구조적 프로그래밍에서는 함수 단위로 구성되며 기능별로 묶어놓은 특징이 있다.
* 객체지향 프로그래밍(Java,C++,C#) : 주 구성요소는 클래스와 객체이다. 그리고 상속, 캡술화와 다형성을 특징으로 들 수 있다. 클래스를 활용하여 각각의 기능별로 구성이 가능하며, 이를 나중에 하나로 합쳐서 프로그램의 완성이 가능하다. 객체 별로 개발이 가능하기에 팀 프로젝트를 하기에도 유리한 장점을 가지고 있다. 또한 코드의 재사용이 가능하며, 오류 발생 가능성이 적고 안정성이 높다.

### Java의 특징
* 자바가상머신(JVM)만 설치하면 컴퓨터의 운영체제에 상관없이 작동한다. 즉, 플랫폼에 독립적이다.
* 기본 자료형을 제외한 모든 요소들이 객체로 표현 가능하다.
* 객체지향개념의 특징인 캡슐화, 상속, 다형성이 잘 적용되어 있는 언어이다.
* Garbage Collector가 메모리를 알아서 관리해준다.
* 멀티스레드를 지원한다.

### 오버로딩과 오버라이딩
* Overloading : 같은 이름의 메서드를 여러개 정의하는 것. 단, 매개변수의 타입이 다르거나 갯수가 달라야한다. 리턴 타입이나 접근 제어자는 영향을 주지 않는다.
* Overriding : 상속에서 나온 개념. 클래스를 메서드의 하위 클래스에서 재정의 하는 것을 의미한다.

### 상속이란?
* 상속은 기존의 클래스를 토대로해서 새로운 클래스를 만드는 방법이라고 할 수 있다.
* 클래스 A가 클래스 B를 상속받게 만들면 클래스 B는 “부모 클래스”가 되고, 클래스 A는 “자식 클래스”가 된다.
* Is-a관계까 성립되어야한다.(~은 ~이다.) 예를 들어 사람과 학생의 관계를 생각해보자.
	* 사람은 학생이다. : X
	* 학생은 사람이다. : O Student클래스는 자식 클래스, Person클래스는 부모 클래스로 상속된다.
* 부모 클래스는 자식 클래스에게 자신의 모든 멤버 변수와 함수를 물려준다. 물론 OOP에서는 물질적인 것 뿐만 아니라, 어떤 기본적인 사람의 특성들도 상속의 특성이 될 수 있다.

### Abstract Class(추상 클래스) 란?’
* 추상메서드를 하나 이상 가진 클래스이다
* 자신의 생성자로 객체 생성이 불가능하다. 그 이유는 몸체도 정의되어 있지 않은 추상 클래스의 객체를 만드는 것은 아무런 의미가 없기 때문이다. 하지만 추상 클래스의 포인터는 선언이 가능하다.
* Ex) 리모콘을 만들때 전원버튼,소리조절,채널조절, 숫자버튼이 있어야할것인데 이들의 동작추상 매서드를 미리 정의한 필드와 메서드가 있으면, 실체클래스에서는 추상클래스에서 명명된 필드와 메서드를 무조건 사용해야한다 -> 필드와 메서드의 이름을 통일하고 유지보수성을 높일 수 있다. 또한, 설계시간이 줄어든다.
* 순수가상함수가 하나라도 선언되어있다면 그 클래스는 추상 클래스
	* 순수가상함수 -> 추상메서드! 
	* 상속받는 실체메서드에서 반드시 재정의(오버라이딩)해줘야 한다 -> 다형성
	* Public class dog extends animal
* 하위 클래스를 참조하여 상위 클래스의 객체를 생성한다
* 하위 클래스를 제어하기 위해 사용한다.

### Interface 란?
* 일종의 추상 클래스이다.
* 오직 추상메서드와 상수만을 멤버로 갖는다.
* 상속의 관계가 없는 클래스간 서로 공통되는 로직을 구현하여 쓸 수 있도록 한다.

### 다형성이란?
* 서로 다른 객체가 동일한 메시지에 대하여 서로 다른 방법으로 응답할 수 있는 기능. 즉, 같은 메서드 호출에 대해 서로 다른 방법으로 응답을 하게 되는 것(상속에서 효과 발휘)
* 예를 들어 Figure 클래스를 상속하는 Triangle, Square, Circle클래스가 있다. Figure클래스는 하위 클래스에서 모형을 그리는데 사용하는 draw 메서드를 가지고 있지만 실제 도형을 그리는 함수 구현 부분을 정의할 수 없다. -> 각 클래스마다 그리는 방법이 다르기 때문이다. 객체지향에서는 이러한 경우 Figure클래스를 추상 클래스로 정의하고 draw함수 역시 추상 메서드라 정의하여 상속 받은 자식클래스에서 새롭게 정의를 내린다.

### 가상함수와 순수가상함수의 차이
* virtual void func(); 와 virtual void func() = 0;
* 객체포인터 변수에 부모클래스와 자식클래스가 담았을 때 오버라이딩된 함수를 실행하게 되면 무조건 **부모함수**를 실행하게 된다. 자식클래스에서 재정의한 의미가 없어진다. -> 그렇기 때문에 **virtual**이라는 키워드를 사용하여 가상함수로 만들게 된다면 객체포인터 변수에서 각각 해당하는 클래스의 함수를 호출하게 된다.
* 만약 부모클래스에서 재정의 할 함수 앞에 virtual키워드를 사용하면 자식클래스는 키워드를 적지 않아도 컴파일러에서 자동으로 가상 함수가 정의가 된다. 하지만 소스 코드의 이해를 돕기 위해 자식클래스에서도 virtual 키워드를 적는것이 관례
* 순수가상함수는 가상함수와 달리 함수의 선언만 있고 정의는 없는것으로, 자식 클래스에서 반드시 재정의하여야만 한다. **재정의 하지 않는다면 오류 발생**
* 예를 들면 동물은 먹는다,잔다, 울다 등의 행동을 가지고 있기 때문에 동물 클래스를 상속받는 자식클래스들은 항상 이 행위들을 가지고 있어야 한다. 개는 멍멍,고양이는 야옹 등등..

### Virtual table(가상 테이블)이란?
* 클래스 안에 가상함수가 포함되어 있을 시 객체를 생성할 때 가상함수를 가리키는 포인터가 생성된다.
* 이 포인터는 가상테이블의 시작주소를 가리키는 포인터고, 각 클래스마다 하나의 고유 가상테이블이 생성된다.
* 고유의 가상테이블은 가상함수를 가리키는 함수포인터배열로 되어있다. 즉, 가상 함수를 실행하려면 vptr -> vtable -> func() 를 호출하게 되는 것


### 스크립트 언어 vs 컴파일 언어
* 스크립트 언어(JavaScript, Python, Ruby..) : 컴파일러가 존재하지 않는다. 실행될 때 바로 해석하므로 코드 변경시 실행 할 때마다 결과가 바뀌게 된다.
* 컴파일러 언어(C,C++,C#,Java) : 컴파일러가 존재한다. 한번 컴파일 된 후에는 코드 수정 후 재 컴파일을 하기전까지 같은 결과를 나타낸다.

### 프로그램, 프로세스, 스레드
* Program : 저장소에 존재하는 코드의 뭉치. 예를 들어 워드, 엘셀 등이 해당된다.
* Process : 저장소에 존재하는 프로그램이 컴퓨터가 실행해서 CPU가 처리할 수 있게 메인 메모리에 올라온 상태.
* Thread : 프로세스 안에 있는 작은 실행단위의 프로세스와 Data영역과 Code영역은 공유하고 스레드 각각의 스택과 레지스터를 갖는다.

### 멀티프로그래밍, 멀티프로세싱, 멀티스레딩, 멀티태스킹
멀티프로그래밍 
* 초창기 싱글코어 싱클 스레드 컴퓨터에서는 프로그램이 메모리에 하나만 올라가고 해당하는 프로그램만 CPU가 처리를 진행할 수 있었다. 이런 과정에서 프로그램이 파일 입출력을 하게 되면 중간에 Idle(정지)상태가 되는데 이 때 다른 프로세스의 일부를 싱행시키는 걸 의미한다.

멀티프로세싱 
* 하나의 컴퓨터에 여러개의 CPU를 장착하고 하나 이상의 프로세스들을 동시에 처리하는 것을 의미한다.
* 더 넓은 범위로 해석하면 하나 또는 그 이상의 프로세스를 여러 장치에서 병렬로 처리하는 것을 의미한다.

멀티태스킹 
* 말 그대로 프로세스내에서 하나의 스레드가 아닌 여러개의 스레드를 형성하여 명령어를 처리하는 것을 의미한다.

멀티태스킹 
* 테스크란 OS에서 처리하는 작업단위를 의미하는데, 그 여러 작업 단위가 빠르게 처리되어 동시에 처리되는 것처럼 보이는 것을 의미한다.
* 여기서 말하는 작업 단위란 처리해야하는 여러 프로세스들의 명렁어를 쪼갠거라고 생각하면 된다.

### 프로세스와 스레드의 차이
* 프로세스 : 실행중인 프로그램을 나타낸다. 이는 CPU가 실행되고 있는 프로세스에 대해서 메모리 자원을 안정되게 분배해줘야하며 이는 운영체제의 성능에 따라 결정된다.
* 스레드 : 하나의 프로세스 내에서 할당받은 자원을 공유하며 실행되는 독립적인 작업단위이다. 즉, 스레드는 각자의 스택 메모리 영역을 가지고 있으며 동일한 프로세스 내의 다른 스레드들과 전역 메모리를 공유한다. 따라서 CPU로부터 새로운 자원을 할당받지 않아도 되기 때문에 프로세스보다 실행 속도가 빠르다는 장점을 가지고 있다.

### 스레드를 생성하는 방법과 장/단점
* 생성방법 : Runnable(인터페이스)로 선언되어 있는 클래스를 상소받거나, Thread클래스를 상속받아 run()메서드를 구현해주면 된다.
* 장점 : 빠른 프로세스 생성, 적은 메모리 사용, 쉬운 정보 공유
* 단점 : 교착 상태에 빠질 수 있다.

### 교착상태(Dead Lock)
* 정의 : 두개이상의 작업이 서로의 작업이 끝나기를 기다리는 상태. 아무것도 하지 못함
* 원인 : 
	* Mutual Exclusion : 자원에 대해 배타적 통제권 요구
	* Hold and Wait : 자원을 가진 상태에서 다른 자원을 기다림
	* No preemption(비선점) : 양보하지 않는다(다른 프로제스가 선점할 수 없도록)
	* Circual wait : 각 프로세스가 순환적으로 다른 프로세스가 요구하는 자원을 기다림
	* 4가지 조건들은 서로 완전히 독립하진 않는다
* 관리방법 : 
	* 예방 : 원인을 제거한다 (ex 비선점형을 선점형으로)
		*  Mutal Exclusion 과 Hold and wait제거 -> 한 프로세스에 필요한 자원을 모두 할당
		* 문제 : 기아상태, 무한대기
		* 비선점형을 선점형으로
		* Circular wait제거 -> 순서를 정한다
	* 회피 : Deadlock을 확인하고 가능성이 있으면 자원을 할당하지 않는다
		* 데드락을 확인하는 기법으로는 자원할당그래프와 은행원알고리즘이 있다.	
	* 무시 : 예방과 회피기법은 성능에 큰 영향을 미칠 수 있다. 데드락이 발생할 확률이 비교적 낮다면 별다른 조치를 취하지 않고 무시한다.
	* 발견 : 자원할당 그래프를 그려서 사이클을 확인한다. 회피와는 다르게 희생자를 만들어서 문제를 해결한다.(자원을 뺏어온다?)
	* ![](&&&SFLOCALFILEPATH&&&bear_sketch@2x.png)
![](&&&SFLOCALFILEPATH&&&bear_sketch@2x.png)

### 임계구역 (Critical Section)
**정의**
* 둘 이상의 스레드가 동시에 접근해서는 안되는 공유자원을 접근하는 코드의 일부
* 이때 공유자원의 배타적 사용을 보장받기 위해 임계구역에 들어가고 나올때 동기화 매커니즘이 필요하다.
**해결책**
* Mutal Exclusion(상호배타) : 데이터에 대한 접근은 한 프로세스만 가능
* Progress(진행) : 아무도 접근하지 않으면 접근할 수 있어야 한다.
* Bounded Waiting(유한대기) : 기다리면 접근할 수 있어야 한다.
**이를 이용한 알고리즘** -> 세마포어(프로세스 단위), 뮤텍스(쓰레드 단위)
예시 **<Producer - Consumer 문제> - 유한버퍼문제**
* 임계구역 진입이 허용되지 않을 때 CPU를 낭비하지 않고 블록하는 프로세스간 통신, 그 중 가장 간단한 것이 sleep & wait ( 시스템 호출을 이용 )
* Producer : 버퍼가 가득차있을 때 sleep()
* Consumer : 버퍼가 비어있을 때 sleep()
-> 세마포어 (Semaphore) : 새로운 변수명을 도입해서 미리 호출한 wakeup횟수를 저장
```
void producer(){
	while(True){
		produce();
		down(e);
		down(mutex);
		//임계구역
		append();
	}
}
```


* E : empty(buffer size)
* N : 0부터 갯수
* Mutex : 1 또는 0
-> 뮤텍스
* 스레드 단위 동기화
* 세모포어의 단순 버전
* 운영체제에게 시스템호출을 하지 않는다
* Lock을 획득하지 못하면 다른 thread에게 cpu를 양보한다


### 동기화란 무엇이며 어떠한 경우에 사용하는가?
* 다중 스레드에서 하나의 자료에 접근할 때 사용한다.
* 예를 들면, 은행계좌에 있는 돈에 대하여 동시에 출금 요청이 가능하다면 한 쪽에서 출급처리가 완료되기 전에 다른 쪽에서 출금을 요청하면 출금이 될 수 있기 때문에 반드시 동기화를 해서 작업이 일어나는 중에는 다른 쪽에서의 접근을 막아주어야한다.


### 포인터의 개념
* 포인터랑 메모리 주소를 저장하는 변수이다
* 예를 들면, 주소를 지칭하고 있는 곳이다. 엘리베이터에서 포인터는 해당 층을 표시하는 버튼이며, 10층 버튼을 누르면 10층으로 이동하듯이 해당 위치를 가리키고 있는 변수이다.
* *포인터를 사용할 때 주의할 점은 어떠한 주소를 가리키고 있어야 사용이 가능하다.

### 변수들이 메모리에 저장되는 역역
* __________________________________________
* Code 영역 : 함수, 제어문, 상수 등등 함수에 대한 기계어 코드가 들어감
* Data 영역 : 초기값이 있는 전역변수, 배열, static으로 선언된 변수가 들어감 
* Bss 영역 : 초기값이 없는 전역변수, 배열, static으로 선언된 변수가 들어감
* Compile time에 크기가 결정되고 이후로 변동되지 않는다.
* ____________________________________________
* Heap 영역 : 동적할당으로 할당된 변수가 들어감, 프로그래머 영역
* Stack 영역 : 지역변수, 블록내에서 할당된 변수가 들어감. 블록을 벗어나면 사라짐
* Run time에 Bss와 Heap사이를 기준으로해서 Heap은 아래로 순차적으로 메모리를 사용하고 Stack은 위쪽으로 순차적으로 메모리를 사용한다
* ___________________________________________

### Call by reference와 Call by value
* Call by reference : 매개변수로 원래 주소 값을 전달하는 방식, 자바에서는 객체를 매개변수로 전달하였을 경우에 해당한다.
* Call by value : 매개변수로 기본 데이터 형을 사용한다. 주어진 값을 복사하여 처리하는 방식으로 함수 내의 처리결과는 함수 밖의 변수에는 영향을 미치지 않는다.

### 재귀함수란?
* 재귀함수란 함수 내에서 자기 자신을 다시 호출하는 형태
* 장점 : 소스코드의 간결화가 가능하다.
* 단점 : 연산 시간이 오래 걸린다. 또한, 잘못 작성 시 프로그램이 무한루프에 빠질 수 있다.

### 디자인 패턴을 사용하는 이유?
* 디자인패턴이라 여러 프로그래머들의 경험과 지혜를 모아서 공통적인 소프트웨어 디자인 문제를 해결하는데 도움이 될 수 있게 만들어 놓은 것
* 가장 대표적인 디자인패턴 -> 싱글톤 : 전체 프로그램에서 단 1개의 객체를 생성하고 공유하는데 사용하는 패턴이다. 주로 Android에서 소켓 객체를 사용할 때 사용한다.

### MVC vs MVP vs MVVM
* 프레임워크 패턴이다. 화면에 보여주는 로직과 실제 데이터가 처리되는 로직을 분리하는 장점을 지닌다.
* MVC (Model + View + Controller)
	* ![](&&&SFLOCALFILEPATH&&&image.png)
	* Model : 프로그램에서 사용되는 실제 데이터 및 데이터 조작 로직을 처리하는 부분
	* View : 사용자에게 제공되어 보여지는 UI부분
	* Controller : 사용자의 입력을 받고 처리하는 부분
	1. Controller로 사용자의 입력이 들어온다
	2. Controller는 Model을 업데이트및 불러오고
	3. Model은 해당 데이터를 보여줄 View를 선택해서 화면에 보여주게 된다
	* 단점 : View와 Model이 서로 의존적이다. 
* MVP ( Model + View + Presenter )
	* ![](&&&SFLOCALFILEPATH&&&image.png)
	* Presenter : View에서 요청한 정보를 Model로 부터 가공해서 View로 전달하는 부분
	* MVC의 단점인 뷰와 모델의 의존성이 사라진다.
	1. View로 사용자의 입력이 들어온다
	2. View는 Presenter에 작업 요청을 한다
	3. Presenter에서 필요한 데이터를 Model에 요청한다.
	4. Model은 Presenter에 필요한 데이터를 응답한다
	5. Presenter는 View에 데이터를 응답한다.
	6. View는 Presenter로부터 받은 데이터로 화면에 보여준다
	* 단점 : View와 Presenter가 1:! 강한 의존성을 가지게 된다 

* MVVM ( Model + View + ViewModel)
	* ![](&&&SFLOCALFILEPATH&&&image.png)
	* ViewModel : View를 표현하기 위해 만들어진 View를 위한 Model
	* MVVM은 Command패턴과 Data Binding패턴을 사용한다. 이를통해 뷰와 모델의 의존성을 완전히 없앤다. 
	1. View에 입력이 들어오면 Command패턴으로 ViewModel에 명령을 한다.
	2. ViewModel은 필요한 데이터를 Model에 요청한다
	3. Model은 ViewModel에 필요한 데이터를 응답한다.
	4. ViewModel은 응답 받은 데이터를 가공해서 저장한다
	5. View는 ViewModel과의 Data Binding으로 인해 자동으로 갱신된다.

### 디스패쳐 서블릿


### UML 이란?
* Unified Modeling Language = “객체 모델링 언어” = “통합 모델링 언어”
* 시스템 설계, 요구분석, 시스템 구현 등의 과정에서 사용되는 모델링 언어로 표기법의 표준화를 목적으로 한다.
* 시스템에 대한 동일한 의미를 공유할 수 있게 하여 언어를 가시화시킬 수 있고 시스템 구조와 모든 상세 내역에 대해 문서화하여 모델링하는 기능들을 제공하며, 다양한 모델링 도구로서의 다이어그램들로 이루어져있다.

#### UML Diagram의 종류
* 클래스 다이어그램 : 클래스 별로 연관관계를 나타내는 다이어그램
* 유스케이스 다이어그램 : 행위자(Actor)와 UseCase로 구분되어 그려진다.
* 상태 다이어그램 : 현재 상태를 나타내는 다이어그램
* 시퀀스 다이어그램 : 시간의 흐름에 따라서 나타내는 다이어그램
* 액티비티 다이어그램 : 처리과정, 수행되는 동안 일어나는 일을 나타낸다.

### 프로젝트 관리 모형의 종류, 설명, SDLC
* 소프트웨어 개발 생명 주기(SDLC) 란 정보 시스템을 계획, 개발, 시험, 채용하는 과정을 뜻한다. 대개 요구사항 분석 -> 설계 -> 개발 -> 테스트 -> 운영 단계로 구성되어 있다.
* 폭포수 :
	* 문서 중심의 모델이다. 즉, 현 단계에서 다음 단계로 이동되는 주요 산출물은 문서이다. 
	* 각 단계를 확실히 매듭짓고 그 결과를 철저하게 검토 후 승인, 이전 단계로 돌아가기 어려움으로 확실하게 검토해야 함
	* 장점 : 프로젝트 라이프사이클 설계에 드는 시간이 짧다. 비교적 경험이 부족한 스태프들을 활용하기 적합하다. 프로젝트를 관리하기 쉽다
	* 단점 : 프로젝트의 중간 이후 단계에서나 사용자 요구사항에 대한 검증이 가능하다. 단계간 검증시 주로 문서가 사용되므로 요구되는 문서량이 많다. 단계간의 융통성이 적다.
* 프로토타입 : 
	* 사용자의 요구 사항을 정확히 파악하고 결과물을 예측하여 만들어내는 모형물, 사용자에게 미리 보여줄 수 있지만 결과물과 조금 다를 수도 있고 단기간에 만들어야한다.
* 나선형 모델 : 
	* 가장 현실적인 모형으로 비교적 최신형태이다. 점진적으로 개발 과정이 순한하며 진행된다.
	* 소프트웨어 프로젝트를 작은 프로젝트로 잘게 나눈다. 각각의 미니 프로젝트들은 전체 모든 중요한 위험 요소가 규명될때까지 하나 혹은 그이상의 중요한 위험요소를 규명한다.
* 애자일? : 

### 형상관리?

### 프레임워크란?
* 특정 형태의 소프트웨어 문제를 해결하기 위해 상호협력하는 클래스 프레임과 인터페이스 프레임의 집합
* 특정 개념들의 추상화를 제공하는 여러 클래스나 컴포넌트로 구성되며, 컴포넌트들은 재사용이 가능하다.
* 스켈레톤 코드라고도 불리는데, 특정한 틀을 만들어놓고 거기에 살을 붙여 놓음으로써 프로그램을 만들어 작업시간을 줄여주는 것이다.
	* 장점 : 개발 시간을 줄일 수 있고, 오류로부터 자유로울 수 있다.
	* 단점 : 프레임워크에 너무 의존하면 개발 능력이 떨어져서 프레임워크 없이 개발하는 것이 불가능해질 수 있다.

### Ajax통신
<!--stackedit_data:
eyJoaXN0b3J5IjpbNjgzODQ0NTYsLTE4Mjg2ODE2OTAsMzk1Mj
gyMTA0LDI3MDI1OTQ5NiwxMjUxNzk3MjQwXX0=
-->