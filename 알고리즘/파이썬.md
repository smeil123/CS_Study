> 파이참 shift + F10

# 파이썬

## 나누기 연산
 ``` python

print(a/b) # 나누기
print(a%b) # 나머지
print(a//b) # 몫
print(a**b) # 거듭제곱

```

## List
* 순서 있음
C의 Array기능, C++의 vector와 유사함
내부적으로 연결 리스트 자료구조를 채택하고 있어서 append(), remove() 등의 메서드를 지원한다.
```python
a = [1,2,3]
a = list()
a = []

n = 10
a = [0] * 10

a = [1,2,3,4,5,7,8,9]
# 뒤에서 첫 번째 원소
print(a[-1])
# 뒤에서 세 번째 원소
print(a[-3])
# 두 번째 원소부터 네 번재 원소까지
print(a[1:4])

# 리스트 컴프리헨션
# 0부터 19까지의 수 중에서 홀수만 포함하는 리스트
array = [i for i in range(20) if i%2 == 1]
# 1부터 9까지의 수의 제곱 값을 포함하는 리스트
array = [i*i for i in range(1,10)]

# N X M 크기의 2차원 리스트 초기화
n = 3
m = 4
array = [[0] * m for _ in range(n)]
```

> _ 의 역할
> 파이썬 자료구조/알고리즘에서 반복을 수행하되 반복을 위한 변수값을 무시하고자 할때 사용


### 리스트 관련 기타 메서드

* append() # O(1)
* sort() / sort(reverve=True)
* reverse()
* insert(index,data) # O(N)
* count(data)
* remove(data) # O(N)

insert()를 사용하여 원소 N개를 입력하면, 시간 복잡도는 O(N)인 반면,
append()를 사용하면 O(1)으로 더 빠름!

remove()도 시간복잡도를 보면 O(N)으로 삭제하는데 시간이 좀 걸린다.

```python
a = [1,2,3,4,5,5,5]
remove_set = {3,5}

#remove_set에 포함되지 않은 값만을 저장
result = [i for i in a if i not in remove_set]
print(result) # [1,2,4]
```

## 문자열
C/C++과 다르게 ",'의 차이는 없다
큰따옴표안에 또 큰따옴표를 표현하기 위해선 \ 를 사용

```python
data = 'Hello World'
print(data)

data = "Don't you know \"Python\"?"
print(data)

a = "Hello"
b = "World"
print(a + " " + b)
print(a*3) #HelloHelloHello
print(a[2:4]) #ll (2~3)

```

## 튜플
* 순서 있음

리스트와 비슷하지만,
* 튜플은 한 번 선언된 값을 변경할 수 없음
* 리스트는 대괄호([]), 튜플은 소괄호(())
```python
a = (1,2,3,4)
print(a)
a[2] = 7 # 오류남
```

튜플은 그래프 알고리즘 구현할 때 자주 사용됨. 최단 경로 알고리즘에서 '비용'과 '노드 번호'라는 서로 다른 성질 데이터를 (비용, 노드번호)의 형태로 함께 튜플로 관리하는 것이 관례

## 사전(dictionary)
키값과 값의 쌍을 데이터로 가지는 자료형
내부적으로 해시 테이블을 이용하므로 기본적으로 데이터의 검색 및 수정에 있어서 O(1)의 시간에 처리할 수 있다.
``` python
data = dict()
data['사과'] = 'Apple'

print(data) # {'사과' : 'Apple'}

if '사과' in data:
	print("사과가 있음")

# 키 데이터만 담은 리스트
key_list = data.keys()
# 값 데이터만 담은 리스트
value_list = data.values()

# 각 키에 따른 값을 하나씩 출력
for key in key_list:
	print(data[key])
	
```

## Set
* 중복을 허용하지 않음
* 순서가 없음
* 검색 O(1)
* 특정한 데이터가 이미 등장한 적 있는지 여부를 확인할 때 좋음
```python
# 집합 자료형 초기화 방법 1
data = set([1,2,3,4,4,5])
data1 = {1,1,2,3,4,4,5}

print(a|b) # 합집합
print(a&b) # 교집합
print(a-b) # 차집합

# 새원소 추가
data.add(6)
data.add([7,8])

# 원소삭제
data.remove(3) 
```

## 조건문
```python
x = 15

if x>=10:
	print(x)

if 조건문1:

elif 조건문2:

else:

x in list :
x not in list :

if x >= 10 : result = "Success"
else : result = "Fail"

result = "Success" if x >=10 else "Fail"
```

## 함수
```python
def add(a,b):
	return a+b
print(add(3,7))
```

## 입출력
```python
# 데이터 개수 입력
n = int(input())
# 각 데이터를 공백으로 구분하여 입력
data = list(map(int,input().split()))

# n,m,k를 공백으로 구분하여 입력
n,m,k = map(int, input().split())

# 많은 데이터를 빨리 입력받아야 될때
import sys
sys.stdin.readline().rstrip() # 한 줄씩 입력받음

answer = 7
print("정답은"+str(answer)+"입니다")
print(f"정답은 {answer}입니다")
```
readline()으로 입력받으면 엔터가 줄바꿈 기호로 입력되고, rstrip()으로 공백을 제거함
이 문구는 외워서 사용!


## 내장함수
```python
result = sum([1,2,3,4,5])

result = min([1,2,3,4,5]) # max

# 수식이 문자열 형식으로 들어오면 결과를 반환
result = eval("(3+5)*7") # 56

result = sorted([9,1,8,5,4])
result = sorted([9,1,8,5,4], reverse = True)

# 튜플의 두번째 원소를 기준으로 정렬
result = sorted([('홍길동':35),('이순신':75),('아무개':50), key = lambda x : x[1],reverse = True])

# list같은 iterable 객체는 기본으로 sort()를 내장하고 있음
data = [9,1,8,3]
data.sort()
```

## inertools
파이썬에서 반복되는 데이터를 처리하는 기능을 포함하고 있는 라이브러리이다.
순열과 조합에서 유용하게 사용할 수 있다

```python
from itertools import permutations
data = ['A','B','C']
result = list(permutations(data,3) # 모든 순열 구하기 (data에서 3개를 순서대로 뽑기)

from itertools import combinations
result = list(combinations(data,2)) # 2개를 뽑는 모든 조합

from itertools import product
result = list(product(data,repeat=2)) # 2개를 뽑는 모든 순열 구하기(중복 포함)

from itertools import combinations_with_replacemet
result = list(combinations_with_replacement(data,2)) # 2개를 뽑는 모든 조합 구하기(중복 포함)
```

## heapq
다익스트라 최단 경로 알고리즘을 포함해 다양한 알고리즘에서 우선순위 큐를 구현하고자 사용
(PriorityQueue 라이브러리도 사용할 수 있지만 heapq가 더 빠름)
* 최소힙으로 구성 O(nlogn) 
* 최대힙은 제공하지 않음. 데이터를 넣을때 부호를 바꿨다가 돌려놓는 방식 사용

```python
import heapq

def heapsort(iterable):
	h = []
	result = []
	# 모든 원소를 차례대로 힙에 삽입
	for value in iterable:
		heaqp.heappush(h,value)
		#heaqp.heappush(h, -value)
	# 힙에 삽입된 모든 원소를 차례대로 꺼내어 담기
	for i in range(len(h)):
		result.append(heapq.heappop(h))
		#result.append(-heapq.heappoo(h))
	return result
result = healsort([1,2,1,5,3,5,2])
```

## bisect
* 이진탐색 시 사용
* 정렬된 배열에서 특정한 원소를 찾아야 될 때 O(logN)
	* bisect_left(a,x) : 정렬된 순서를 유지하면서 리스트 a에 데이터  x를 삽입할 가장 왼쪽 인덱스를 찾는 메서드
	* bisect_right(a,x) : 정렬된 순서를 유지하도록 리트스 a에 데이터 X를 삽입할 가장 오른쪽 인덱스를 찾는 메서드
* 정렬된 리스트에서 '값이 특정 범위에 속하는 원소의 개수'를 구하고자 할 때 효과적으로 사용할 수 있음
	* [left_value, right_value] 에 속하는 데이터의 개수를 반환

1 2 bisect_left(a,4) 4 4 bisect_right(a,4) 8

```python
from bisect import bisect_left, bisect_right
a = [1,2,4,4,8]
x = 4

print(bisect_left(a,x)) # 2
print(bisect_right(a,x)) # 4

# 값이 [left_value, right_value]인 데이터의 개수를 반환하는 함수
def count_by_range(a, left_value, right_value):
	right_index = bisect_right(a,right_value)
	left_index = bisect_left(a,right_value)
	return right_index - left_index
``` 

## collectons
* deque(큐대신 자주 사용), counter 라는 유용한 자료구조 제공
* 
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTAzNzA3Mzc4MSwtMjAzMTMwMDA4OCwxNz
MyNDU2ODgsMTc3MDM0MDU3MSwxNDM4NzY3Mzg0LC0xODg0OTM3
OTQyLDk5MjQ0Njg1Ml19
-->