
기본
	1.	문자열
	2.	정렬
	3.	스택
	4.	큐
	5.	우선순위큐(힙)
	6.	Set, Map
	7.	이분탐색
	8.	DFS(깊이 우선 탐색)
	9.	BFS(너비 우선 탐색)
	10. 백트래킹
	11. 시뮬레이션, 구현 (삼성 기출의 대부분)
	12. 그리디(탐욕법)
	13. 누적합
	14. 분할정복
	15. 투포인터(두 포인터)
	16. 위상정렬
	17. DP

심화
	1.	다익스트라
	2.	플로이드 와샬
	3.	벨만 포드
	4.	유니온-파인드 (Disjoint set)
	5.	MST(최소 스패닝 트리), 크루스칼
	6.	세그먼트 트리
	7.	트라이

## DFS

## BFS

## 백트래킹

## DP

### 편집거리
https://www.acmicpc.net/problem/7620 풀어보기

## 다익스트라

## 벨만 포드
> D(s,u) = D(s,v) + w(v,u)

s,u사이의 최단 경로는 
- 최선 : s - u로 바로 가기
- 최악 : u를 제외한 그래프의 모든 노드가 최단

### 동작방식
1. ah


## Kruskal(유니온-파인드, MST)

탐욕적인 알고리즘으로 MST(최소 비용 신장 트리)를 만들 때 사용한다.
네트워크의 모든 정점을 최소 비용으로 연결하는 해답을 구하는거(N개의 노드를 N-1개의 edge로 잇기)

### 동작방식
1. 그래프들의 간선들을 가중치의 오름차순으로 정렬
2. 정렬된 간선 리스트에서 순서대로 사이클을 형성하지 않는 간선을 선택 -> Find
3. 해당 간선을 현재 MST의 집합에 추가 -> Union

사이클을 찾기위해 유니온 파인드 기법을 사용함

### 유니온 파인드 동작방식
1. 각 노드들의 루트 노드를 자기자신으로 초기화
2. find - x,y의 루트노드를 찾음
3. Union - x,y의 루트노드가 다르다면 y를 x의 자손으로 넣어 두 트리를 합한다
	-> x,y 중 작은 값을 조상으로(부모값이 더 작은게 들어감)
	
[https://www.acmicpc.net/problem/2887](https://www.acmicpc.net/problem/2887)

```c++
#include<iostream>
#include<algorithm>
#include<vector>
#include<cstdlib>
using namespace std;
bool compare_n(pair<long, int> i, pair<long, int> j) { return i.first < j.first; }

typedef struct xyz {
	int n, x, y;

	bool operator < (const struct xyz& other) const {
		return n < other.n;
	}
};


int n;
int p_arr[100001];
vector<pair<int, int>> node_x;
vector<pair<int, int>> node_y;
vector<pair<int,int>> node_z;
vector<vector<pair<long, int>>> edge_cal;
vector<xyz> edge;

int Find(int x) {
	//조상님 찾기
	while (true) {
		if (x == p_arr[x]) return x;
		x = p_arr[x];
	}
}

int main() {

	int x,y,z;
	cin >> n;
	for (int i = 0; i < n; i++) {
		cin >> x >> y >> z;
		node_x.push_back({ x,i });
		node_y.push_back({ y,i });
		node_z.push_back({ z,i });
		p_arr[i] = i; //초기 부모 셋팅
	}

	sort(node_x.begin(), node_x.end());
	sort(node_y.begin(), node_y.end());
	sort(node_z.begin(), node_z.end());
	//노드간 간선 가중치 구하기
	edge_cal.resize(n);
	for (int i=0; i < n - 1; i++) {
		edge.push_back({ abs(node_x[i + 1].first - node_x[i].first), node_x[i].second, node_x[i + 1].second }); // edge= {x 가중치,i, j}
		edge.push_back({ abs(node_y[i + 1].first - node_y[i].first), node_y[i].second, node_y[i + 1].second });
		edge.push_back({abs(node_z[i + 1].first - node_z[i].first), node_z[i].second, node_z[i + 1].second });
	}

	sort(edge.begin(), edge.end());

	int sum = 0, cnt = 0;
	int i = 0; // 마지막 자식
	while (cnt < n-1) {
		int c = Find(edge[i].x);
		int p = Find(edge[i].y);

		if (c != p) {
			// 더 큰수의 조상을 작은 수로
			if (c > p) p_arr[c] = p;
			else p_arr[p] = c;
			sum += edge[i].n;
			cnt++;
		}
		i++;
	}

	cout << sum << endl;

	return 0;
}
```


<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE5OTc4NjMzMjYsLTY3MjM5MzI3NiwxNj
MzMjcxNDk4XX0=
-->